## 这个项目是什么？
这个项目的初衷，是想通过这个项目来推进项目重构，主要职责就是负责加载并聚合各个项目，甚至不仅仅是新老项目，也可以是其余子项目，也可以认为是一个小型微前端框架。其实这就是一种微前端的实现方式，只是我的方案更轻量，更适合用于项目重构这一场景（PS：至少我是这么觉得的）。简单介绍过之后，接下来就要讲一些具体的使用方法。

## 使用方法
使用方法很简单，只需在`config`文件夹下，写入我们需要加载的项目的配置文件即可，此文件应导出一个对象，具体配置属性见`config`文件夹下的样例文件`old.js`。注释已经写的满满当当了，照着写配置就好。如果想要加载其余新的项目或资源，在`config`文件夹下新增一个新的配置文件即可。如果指定了`root`，请确保`index.ejs`有对应的元素。
```js
export default {
    // 项目名称，作为当前配置项的唯一标识符，必填
    name: 'old',
    // 必填，指定加载的类型，为资源或者项目，枚举：project，resource
    type: 'project',
    // 非必填，指定一个根元素，当前项目的html元素会被加载到此元素下
    root: '#oldApp',
    // 必填，加载优先级，小数字代表高优先级
    priority: 1,
    // 当type === project时必填，因为要通过发起跨域请求去获取到目标项目的主页面内容，所以需要进行一层代理
    proxyUrl: './getOldHtml/index.html',
    // 非必填，当type === resource时有效，要加载的js文件
    scripts: [],
    // 非必填，当type === resource时有效，要加载的样式文件
    styles: [],
    // 非必填，指定后，符合正则匹配的资源将不会被加载
    exceptResourceRule: /^a.js$/,
    // 非必填，指定后会为所有的资源文件(不是一个完整链接的文件地址，即不包含domain的文件)添加的前缀地址，一般来说，即为代理地址
    prefixUrl: './getOldHtml',
    // 当前项目js文件加载前钩子
    beforeLoad() {
        // ...
    },
    // 当前项目所有js文件(不包括内联的js)加载后钩子
    afterLoad() {
        // ...
    },
    // 非必填，路由规则，只有在当前路由下，才会显示root元素
    // 如果不指定，则在任何情况下都会显示root元素
    // 如果指定，则在路由匹配的情况下，才会显示root元素，不匹配的情况下会为root元素设置display:none
    // 暂时只支持hash模式
    routesRule: /^printBatch$/,
    // 使用沙箱模式，此配置项会将当前项目配置下的，符合匹配条件的js文件运行在一个独立的window对象下
    // 一般的，不是很建议使用，如果用到了一些全局变量以外的东西，容易产生一些不可预见的错误
    // 考虑是否可以维护一组属性的集合，当访问window下的某些属性在这个集合中时，访问的是真实的window对象
    useSandbox: false,
    // 满足此正则的文件，使用沙箱模式，前置配置useSandbox: true，默认为当前配置下的所有文件都支持
    sandboxRule: /1.js/,
}
```
## EventBus
在当前window下挂载两个属性：`window. $SyncEventBus`和`window. $AsyncEventBus`，这是两个事件总线系统，区分点在于触发事件的方式为同步或异步触发。提供以下方法：

`on(eventname, fn, isMulityListers: boolean)`: 监听某事件，第三个参数表示此事件可拥有多个监听函数

`emit(eventname, param)`: 触发某事件

`off(eventname, ...fn)`: 取消对某些函数的监听

`once(eventname, fn)`: 只会触发一次的事件，触发后会将事件名移除，不允许拥有多个监听函数

`offAll(eventname)`: 取消当前事件名下的所有监听函数

`clear()`: 移除所有的事件监听

关于这个事件系统，我这边的设计是建议为一种一对一的关系，即一个事件名对应一个响应函数。这样设计的初衷在于减少一些隐形bug的发生。设想这么一种情况，程序猿A在某个组件里监听了事件，事件名为event，响应函数为fnA；程序猿B在另一个组件里也监听了event，响应函数为fnB。而实际上这只是一种偶发性的命名冲突，但是却很容易发生一些隐性的bug，因为fnA和fnB都被触发了，如果这是一种不能被直观地看出来的问题，那么排除问题可能会变得有些困难。通过这种一对一的方式，将从根本上排除这种情况的发生。但是如果我需要一种一对多的关系怎么办？没关系，在事件监听的时候，传入的第三个参数为true即为一种一对多的关系。

## request
加载中心在获取到目标项目的页面时，为了方便，就直接使用了fetch，如果觉得可能会有兼容性问题，可以使用传统的Ajax替代，修改src/request文件即可。